# Оптимальная агрегация IP-адресов с минимальным over-blocking

Скрипт для решения задачи **Red-Blue Set Cover** - сжатия большого количества IP-адресов до ограниченного числа CIDR правил с минимальным over-blocking.

## Описание проблемы

Задача: сжать 70,000 IP-адресов (разбросанных по 8,400+ подсетям /24) до ≤2,000 правил с минимальным количеством "лишних" заблокированных IP.

Это NP-трудная оптимизационная проблема, формально известная как **Red-Blue Set Cover**:
- **Синие элементы** = целевые IP (должны быть покрыты все)
- **Красные элементы** = все остальные IP (минимизировать покрытие)
- **Множества** = возможные CIDR-блоки

## Установка

### Базовые требования

```bash
# Python 3.7+
python3 --version

# Для базового функционала (жадный алгоритм, плотностно-ориентированная стратегия)
# Дополнительные зависимости не требуются
```

### Опциональные зависимости для ILP решения

**Примечание:** Скрипт автоматически установит PuLP при использовании метода `ilp`, если он не установлен.

Для ручной установки:

```bash
# Установка PuLP (для ILP решения с CBC солвером)
pip install -r requirements.txt
# или
pip install pulp

# Для использования Gurobi (требует лицензию, бесплатно для академии)
# pip install gurobipy
```

## Использование

### Базовое использование

```bash
# Жадный алгоритм (рекомендуется для быстрого результата)
python3 ip_aggregator.py input.txt -o output.txt -m greedy

# Плотностно-ориентированная стратегия
python3 ip_aggregator.py input.txt -o output.txt -m density

# ILP решение (PuLP будет установлен автоматически при необходимости)
python3 ip_aggregator.py input.txt -o output.txt -m ilp --solver cbc
```

### Параметры

```
positional arguments:
  input_file            Файл с IP-адресами (по одному на строку)

options:
  -h, --help            Показать справку
  -o, --output OUTPUT   Выходной файл для CIDR правил (обязательно)
  -m, --method {greedy,density,ilp}
                        Метод агрегации (по умолчанию: greedy)
  -e, --max-entries N   Максимальное количество правил (по умолчанию: 2000)
  --max-prefix N        Минимальная длина префикса / максимальный размер блока (по умолчанию: 8)
  --solver {cbc,gurobi}
                        ILP солвер (по умолчанию: cbc)
  --metrics             Вывести детальные метрики
  --json                Вывести метрики в формате JSON
```

### Примеры

```bash
# Сжатие до 2000 правил с ограничением максимального размера блока /20
python3 ip_aggregator.py ips.txt -o rules.txt -m greedy --max-prefix 20

# ILP решение с Gurobi (если установлен)
python3 ip_aggregator.py ips.txt -o rules.txt -m ilp --solver gurobi

# С выводом метрик в JSON
python3 ip_aggregator.py ips.txt -o rules.txt -m greedy --json
```

## Формат входных данных

Файл с IP-адресами должен содержать по одному IP на строку:

```
192.168.1.1
10.0.0.5
172.16.0.100
# Комментарии игнорируются
203.0.113.42
```

Также поддерживается формат с портами (берется только IP):
```
192.168.1.1:8080
10.0.0.5:443
```

## Формат выходных данных

Выходной файл содержит CIDR блоки, по одному на строку:

```
10.0.0.0/24
192.168.1.0/25
172.16.0.0/20
```

## Методы агрегации

### 1. Жадный алгоритм (`greedy`)

**Рекомендуется для большинства случаев**

- Гарантия аппроксимации: O(ln n)
- Время выполнения: O(n²) где n - количество кандидатов
- Практически: <1 секунда для 70K IP
- Результат: обычно 1.5-3x от оптимального over-blocking

**Алгоритм:**
1. На каждой итерации выбирает CIDR блок с минимальной "ценой" за покрытие одного нового целевого IP
2. Цена = количество over-blocked IP / количество новых покрытых целевых IP
3. Повторяет до покрытия всех IP или достижения лимита правил

### 2. Плотностно-ориентированная стратегия (`density`)

**Рекомендуется для разреженных распределений (низкая плотность IP в подсетях)**

- Оптимизирована для случаев с ~3-5% плотностью
- Двухфазный подход:
  - Фаза 1: Классификация по плотности /24 подсетей
  - Фаза 2: Приоритизация и жадная агрегация остатка

**Стратегия:**
- ≥80% плотность: агрегировать до /24
- 40-80%: использовать /25 или /26
- <40%: оставить отдельные /32 или агрегировать осторожно

### 3. ILP решение (`ilp`)

**Для получения оптимального решения (требует много времени)**

- Точное решение задачи Red-Blue Set Cover
- Требует установки PuLP
- Время выполнения: минуты-часы для 70K IP
- Результат: минимально возможный over-blocking

**Ограничения:**
- Для больших наборов (>10K кандидатов) может быть непрактично
- Использует жадное решение как warm-start для ускорения

## Метрики качества

Скрипт автоматически вычисляет следующие метрики:

- **Количество правил**: Финальное число CIDR блоков
- **Покрытие**: Процент покрытых целевых IP
- **Over-blocked IP**: Количество "лишних" заблокированных IP
- **Expansion Factor**: Отношение заблокированных IP к целевым (идеал: 1.0)
- **Precision**: Доля целевых IP среди всех заблокированных
- **Rule Efficiency**: Среднее количество целевых IP на правило
- **False Positive Rate**: Вероятность ложного срабатывания

## Ожидаемые результаты

Для типичного случая (70K IP, 3.2% средняя плотность):

| Метод | Правила | Over-blocking | Время | Expansion Factor |
|-------|---------|---------------|-------|------------------|
| Все /32 | 70,000 | 0 | — | 1.0 |
| Lossless aggregation | ~6,000-8,000 | 0 | <1 сек | 1.0 |
| Жадный алгоритм | ~2,000 | ~1-2M IP | <1 сек | ~1.5-3.0 |
| ILP оптимальный | ~2,000 | Минимально возможный | 1-30 мин | ~1.2-2.0 |
| Плотностно-ориентированный | ~2,000 | ~1-3M IP | <1 сек | ~1.5-3.5 |

## Альтернативные инструменты

### firehol/iprange

Если нужен готовый инструмент без Python зависимостей:

```bash
git clone https://github.com/firehol/iprange
cd iprange
./autogen.sh && ./configure && make
./iprange --ipset-reduce 100 --ipset-reduce-entries 2000 -v input.txt > output.txt
```

**Преимущества iprange:**
- Написан на C (быстрее)
- Оптимизирован для производительности firewall
- Минимизирует количество уникальных длин префиксов

**Преимущества этого скрипта:**
- Больше контроля над алгоритмом
- Детальные метрики
- ILP решение для оптимальности
- Легко модифицировать под конкретные нужды

## Математическая формализация

### ILP формулировка

```
Переменные:  x_j ∈ {0,1} для каждого CIDR-блока j
Цель:        Minimize Σ_j (w_j · x_j)
             где w_j = количество нецелевых IP в блоке j

Ограничения: 
  Покрытие:     Σ_{j: i∈S_j} x_j ≥ 1  для всех целевых IP i
  Кардинальность: Σ_j x_j ≤ 2000
  Бинарность:   x_j ∈ {0,1}
```

## Производительность

- **Жадный алгоритм**: O(n²) где n - количество кандидатов CIDR
- **Плотностно-ориентированный**: O(n log n) для классификации + O(n²) для агрегации
- **ILP**: Экспоненциальное в худшем случае, но на практике с warm-start: O(часы)

Для 70K IP:
- Построение кандидатов: ~10-30 секунд
- Жадная агрегация: <1 секунда
- ILP: 1-30 минут (зависит от солвера и данных)

## Проверка покрытия

После агрегации рекомендуется проверить, что все исходные IP-адреса покрыты агрегированными правилами. Для этого используется скрипт `check_coverage.py`:

```bash
python3 check_coverage.py <исходный_файл> <агрегированный_файл>
```

**Пример:**
```bash
python3 check_coverage.py 1.05_7.12_delivery_ip.csv delivery_aggregated.txt
```

### Особенности

- **Оптимизированная производительность**: Использует целочисленное сравнение вместо объектов `ipaddress`, что ускоряет проверку с минут до секунд для больших объемов (70K+ IP)
- **Строгий режим отключен**: Принимает валидные, но "неаккуратные" CIDR-правила (например, `192.168.1.5/24` вместо `192.168.1.0/24`)
- **Детальная статистика**: Показывает процент покрытия и список непокрытых IP
- **Автоматическое сохранение**: Сохраняет непокрытые IP в файл `missing_ips.txt`

### Выходные данные

Скрипт выводит:
- Общее количество уникальных IP
- Количество покрытых IP (в процентах)
- Количество непокрытых IP (в процентах)
- Примеры непокрытых IP (первые 20)
- Полный список непокрытых IP сохраняется в `missing_ips.txt`

**Код возврата:**
- `0` - все IP покрыты
- `1` - есть непокрытые IP

## Лицензия

MIT License

## Автор

Скрипт создан для решения задачи оптимальной агрегации IP-адресов с контролем over-blocking.

